Problem Statement :-

Function - concatSameValues() in DC (Daily Challenge) in SkillRack in C - Programming

Code :-

#include <math.h>

int is_within_bounds(int index , int N){
    
    return ((0 <= index) && (index <= N));
}

void merge_sort(int left_pointer , int right_pointer , int *array){
    
    if(left_pointer >= right_pointer){
        return ;
    }
    
    int middle_pointer = (left_pointer + ((right_pointer - left_pointer) / 2));
    
    merge_sort(left_pointer , middle_pointer , array);
    
    merge_sort((middle_pointer + 1) , right_pointer , array);
    
    int temp_array[(right_pointer - left_pointer + 1)];
    
    int temp_array_index = 0;
    
    int pointer_1 = left_pointer;
    
    int pointer_2 = (middle_pointer + 1);
    
    while((is_within_bounds(pointer_1 , middle_pointer)) && (is_within_bounds(pointer_2 , right_pointer))){
        temp_array[temp_array_index++] = (array[pointer_1] <= array[pointer_2]) ? (array[pointer_1++]) : (array[pointer_2++]);
    }
    
    while(is_within_bounds(pointer_1 , middle_pointer)){
        temp_array[temp_array_index++] = array[pointer_1++];
    }
    
    while(is_within_bounds(pointer_2 , right_pointer)){
        temp_array[temp_array_index++] = array[pointer_2++];
    }
    
    for(int index_1 = left_pointer , index_2 = 0 ; (index_1 <= right_pointer) ; index_1++ , index_2++){
        array[index_1] = temp_array[index_2];
    }
}

int get_length_of_N(int N){
    
    return ((N == 0) ? (1) : (((int) log10(abs(N))) + 1));
}

int get_concatenated_numbers(int A , int B){
    
    return ((A * ((int) pow(10 , get_length_of_N(B)))) + B);
}

boundedArray* concatSameValues(int N , int *array){
    
    merge_sort(0 , (N - 1) , array);
    
    int *new_array = ((int *) malloc((N * sizeof(int))));
    
    int new_array_index = 0;
    
    for(int index = 0 ; (index < N) ; ){
        
        if((is_within_bounds((index + 1) , (N - 1))) && (array[index] == array[(index + 1)])){
            new_array[new_array_index++] = get_concatenated_numbers(array[index] , array[(index + 1)]);
            index += 2;
        }else{
            new_array[new_array_index++] = array[index];
            index += 1;
        }
    }
    
    merge_sort(0 , (new_array_index - 1) , new_array);
    
    boundedArray *bounded_array_reference = ((boundedArray *) malloc(sizeof(boundedArray)));
    
    (bounded_array_reference -> SIZE) = new_array_index;
    
    (bounded_array_reference -> arr) = new_array;
    
    return bounded_array_reference;
}
